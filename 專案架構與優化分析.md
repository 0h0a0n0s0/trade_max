# USDTTWD 網格交易專案 - 架構與優化分析

## 📋 目錄
1. [專案架構總覽](#專案架構總覽)
2. [檔案運行方式](#檔案運行方式)
3. [目標ROI 20% 分析](#目標roi-20-分析)
4. [策略優化建議](#策略優化建議)
5. [Optuna 參數優化建議](#optuna-參數優化建議)
6. [整體流程優化建議](#整體流程優化建議)

---

## 專案架構總覽

### 核心模組

```
NoAI/
├── strategy_usdttwd_grid.py    # 實盤交易策略主程式
├── backtest/
│   └── backtester_grid.py      # 回測系統
├── risk_controller.py           # 風險控制模組
├── max_async_api.py             # MAX交易所API封裝
├── db.py                        # 資料庫連線管理
├── db_schema.py                 # 資料庫模型定義
├── indicators.py                # 技術指標計算
├── telegram_alerter.py          # Telegram通知系統
├── config_usdttwd.yaml          # 策略配置檔案
└── trading.db                   # SQLite資料庫
```

### 策略核心邏輯

**三層固定間隙網格策略 + EMA趨勢偏好**

1. **網格層級**：
   - 小網格 (Small Grid): `small_gap = 0.035 TWD`
   - 中網格 (Mid Grid): `small_gap * 3 = 0.105 TWD`
   - 大網格 (Big Grid): `small_gap * 7 = 0.245 TWD`
   - 每層上下各 6 個掛單

2. **EMA趨勢判斷**：
   - 快線：600分鐘 (10小時)
   - 慢線：3000分鐘 (50小時)
   - 看漲：目標USDT曝險 60%
   - 看跌：目標USDT曝險 25%

3. **風險控制**：
   - USDT淨持倉限制
   - TWD餘額最低門檻
   - 黑天鵝事件保護

---

## 檔案運行方式

### 1. 實盤交易策略

```bash
# 前置準備
# 1. 建立 .env 檔案，包含：
#    MAX_API_KEY="your_api_key"
#    MAX_API_SECRET="your_api_secret"
#    TG_TOKEN="your_telegram_token"
#    TG_CHAT_ID="your_chat_id"
#    DB_URI="sqlite+aiosqlite:///trading.db"  # 可選

# 2. 安裝依賴
pip install -r requirements.txt

# 3. 初始化資料庫（首次運行）
python db.py

# 4. 啟動實盤策略
python strategy_usdttwd_grid.py
```

**運行流程**：
1. 載入配置檔案 `config_usdttwd.yaml`
2. 初始化資料庫連線
3. 初始化MAX API客戶端
4. 清理舊掛單（避免孤兒訂單）
5. 建立初始網格
6. 進入主迴圈：
   - 輪詢訂單狀態
   - 更新餘額
   - 檢查EMA趨勢並調整倉位
   - 定期重建網格（每480分鐘）
   - 檢查黑天鵝事件

### 2. 回測系統

```bash
# 進入回測目錄
cd backtest

# 執行回測
python backtester_grid.py \
    --csv usdttwd_1m_25y7m.csv \
    --config config_usdttwd.yaml \
    --init_usdt 10000.0 \
    --init_twd 300000.0
```

**回測功能**：
- 支援混合模式（網格 + 趨勢跟隨）
- 使用ADX過濾強趨勢市場
- 動態調整網格攻擊性
- 自動生成回測結果圖表

### 3. 其他工具

```bash
# 檢查資料庫PNL
python check_db_pnl.py

# 測試Telegram通知
python test_telegram.py
```

---

## 目標ROI 20% 分析

### 現狀評估

**當前策略特點**：
- ✅ 三層網格設計，捕捉不同波動幅度
- ✅ EMA趨勢判斷，減少單邊行情風險
- ✅ 風險控制機制完善
- ⚠️ 網格間距固定，無法適應市場波動變化
- ⚠️ 無參數自動優化機制
- ⚠️ 回測與實盤參數可能不一致

### ROI 20% 可行性分析

**假設條件**：
- 初始資金：310,000 TWD (10,000 USDT + 300,000 TWD)
- 目標年化ROI：20%
- 目標年收益：62,000 TWD

**計算分析**：

1. **網格收益估算**：
   - 小網格：0.035 TWD/次 × 每日約10-20次成交 = 0.35-0.70 TWD/日
   - 中網格：0.105 TWD/次 × 每日約5-10次成交 = 0.525-1.05 TWD/日
   - 大網格：0.245 TWD/次 × 每日約2-5次成交 = 0.49-1.225 TWD/日
   - **每日網格收益約：1.365-2.975 TWD**
   - **年化收益約：498-1,085 TWD**（僅網格，遠低於目標）

2. **問題診斷**：
   - ❌ **網格間距過小**：0.035 TWD 在30 TWD價格下僅0.12%，手續費0.1%後利潤微薄
   - ❌ **資金利用率低**：每筆訂單僅佔總權益1.5-3.5%
   - ❌ **無趨勢跟隨收益**：實盤策略未實現回測中的混合模式

---

## 策略優化建議

### 1. 網格間距優化 ⭐⭐⭐⭐⭐

**問題**：固定間距無法適應市場波動

**建議**：
```yaml
# 使用ATR動態調整網格間距
use_atr_spacing: true
atr_period: 14
atr_spacing_multiplier: "0.8"  # 從0.5提升到0.8，增加間距

# 或使用波動率分層
volatility_based_spacing: true
volatility_window: 20
low_vol_multiplier: "0.6"   # 低波動時縮小間距
high_vol_multiplier: "1.5"  # 高波動時擴大間距
```

**預期效果**：
- 高波動時擴大間距，提高單筆利潤
- 低波動時縮小間距，增加成交頻率
- 預期提升年化收益至 5,000-8,000 TWD

### 2. 資金利用率優化 ⭐⭐⭐⭐

**問題**：每筆訂單僅佔總權益1.5-3.5%，資金閒置

**建議**：
```yaml
# 增加訂單大小
size_pct_small: "0.025"  # 從0.015提升到0.025
size_pct_mid: "0.040"    # 從0.025提升到0.040
size_pct_big: "0.055"    # 從0.035提升到0.055

# 增加網格層數
levels_each: 8  # 從6提升到8，增加覆蓋範圍
```

**風險控制**：
- 確保總掛單價值不超過總權益的80%
- 保留足夠現金應對單邊行情

**預期效果**：
- 資金利用率從約30%提升至50-60%
- 預期提升年化收益至 8,000-12,000 TWD

### 3. 實現混合模式（趨勢跟隨） ⭐⭐⭐⭐⭐

**問題**：回測中有混合模式，但實盤策略未實現

**建議**：
在 `strategy_usdttwd_grid.py` 中實現：
```python
# 1. 計算ADX指標
adx_value = calculate_adx(PRICE_HISTORY, period=14)

# 2. 判斷市場狀態
if adx_value > 35:  # 強趨勢市場
    # 進入趨勢跟隨模式
    if ema_fast > ema_slow:
        # 做多，只掛買單
        enter_trend_following('long')
    else:
        # 做空，只掛賣單
        enter_trend_following('short')
else:  # 盤整市場
    # 使用網格策略
    use_grid_strategy()
```

**預期效果**：
- 強趨勢市場中避免逆勢網格虧損
- 捕捉趨勢收益
- 預期提升年化收益至 15,000-20,000 TWD

### 4. 網格重建頻率優化 ⭐⭐⭐

**問題**：固定480分鐘重建，可能錯過最佳時機

**建議**：
```python
# 動態重建條件
def should_rebuild_grid():
    # 1. 時間條件：480分鐘
    if time_since_last_rebuild >= 480:
        return True
    
    # 2. 價格偏離條件：價格偏離中心價超過5%
    if abs(current_price - center_price) / center_price > 0.05:
        return True
    
    # 3. 趨勢轉換條件：EMA趨勢發生變化
    if ema_trend_changed:
        return True
    
    return False
```

### 5. 手續費優化 ⭐⭐⭐⭐

**問題**：使用限價單但可能被吃單，產生taker手續費

**建議**：
```python
# 1. 使用post-only訂單（如果交易所支援）
order_type = 'post_only'  # 確保是maker訂單

# 2. 動態調整掛單價格
# 買單：掛在買一價下方1-2個tick
# 賣單：掛在賣一價上方1-2個tick
buy_price = best_bid_price - tick_size * 2
sell_price = best_ask_price + tick_size * 2
```

**預期效果**：
- 手續費從0.1%降低至0.05%或更低（maker費率）
- 預期提升年化收益 2,000-3,000 TWD

---

## Optuna 參數優化建議

### 當前狀況

**❌ 專案中尚未實現Optuna參數優化**

### 實現方案

#### 1. 建立Optuna優化腳本

**檔案**：`optimize_params.py`

```python
import optuna
import yaml
from decimal import Decimal
from backtest.backtester_grid import Backtester
import pandas as pd

def objective(trial):
    # 定義搜尋空間
    small_gap = trial.suggest_float('small_gap', 0.02, 0.10, step=0.005)
    mid_mult = trial.suggest_int('mid_mult', 2, 5)
    big_mult = trial.suggest_int('big_mult', 5, 10)
    levels_each = trial.suggest_int('levels_each', 4, 10)
    
    size_pct_small = trial.suggest_float('size_pct_small', 0.01, 0.05, step=0.005)
    size_pct_mid = trial.suggest_float('size_pct_mid', 0.02, 0.06, step=0.005)
    size_pct_big = trial.suggest_float('size_pct_big', 0.03, 0.08, step=0.005)
    
    ema_fast = trial.suggest_int('ema_span_fast_bars', 300, 1200, step=60)
    ema_slow = trial.suggest_int('ema_span_slow_bars', 1800, 3600, step=300)
    
    recenter_interval = trial.suggest_int('recenter_interval_minutes', 240, 960, step=60)
    
    # 建立配置
    cfg = {
        'small_gap': str(small_gap),
        'mid_mult': mid_mult,
        'big_mult': big_mult,
        'levels_each': levels_each,
        'size_pct_small': str(size_pct_small),
        'size_pct_mid': str(size_pct_mid),
        'size_pct_big': str(size_pct_big),
        'ema_span_fast_bars': ema_fast,
        'ema_span_slow_bars': ema_slow,
        'recenter_interval_minutes': recenter_interval,
        # ... 其他必要參數
    }
    
    # 執行回測
    backtester = Backtester(cfg, Decimal("10000"), Decimal("300000"))
    trade_log = backtester.run(price_df)
    
    # 計算目標函數（ROI）
    final_equity = TWD_BALANCE + USDT_BALANCE * final_price
    roi = (final_equity - initial_equity) / initial_equity
    
    # 考慮風險調整（夏普比率）
    sharpe_ratio = calculate_sharpe_ratio(trade_log)
    
    # 綜合評分：ROI * 0.7 + Sharpe * 0.3
    score = roi * 0.7 + sharpe_ratio * 0.3
    
    return score

# 建立study
study = optuna.create_study(
    direction='maximize',
    study_name='grid_strategy_optimization',
    storage='sqlite:///optuna_study.db',
    load_if_exists=True
)

# 執行優化
study.optimize(objective, n_trials=100)
```

#### 2. Optuna優化策略建議

**✅ 推薦使用Optuna的原因**：
1. **參數空間大**：網格間距、層數、EMA週期等組合數以萬計
2. **非線性關係**：參數之間存在複雜交互
3. **多目標優化**：需要平衡ROI、夏普比率、最大回撤

**⚠️ 注意事項**：
1. **過度擬合風險**：使用Walk-Forward Analysis驗證
2. **計算成本**：每次trial需要完整回測，耗時較長
3. **穩定性**：優化後的參數需要在不同市場環境下測試

#### 3. 優化流程改進

**建議流程**：
```
1. 數據準備
   ├── 訓練集：前70%數據
   └── 測試集：後30%數據

2. Optuna優化（在訓練集上）
   ├── 100-200 trials
   └── 使用TPE採樣器

3. 驗證（在測試集上）
   ├── 測試最佳參數
   └── 計算Out-of-Sample ROI

4. 如果測試集ROI > 15%：
   ├── 自動更新config_usdttwd.yaml
   └── 發送Telegram通知

5. 如果測試集ROI < 15%：
   └── 記錄結果，繼續優化
```

---

## 整體流程優化建議

### 當前流程問題

```
回測 → 手動調整參數 → 實盤運行 → 觀察結果 → 重複
```

**問題**：
1. ❌ 回測與實盤參數可能不一致
2. ❌ 手動調整參數效率低
3. ❌ 無法自動驗證參數有效性
4. ❌ 優化結果未自動應用

### 優化後流程

#### 方案A：自動化優化流程 ⭐⭐⭐⭐⭐

```
1. 定期參數優化（每週/每月）
   ├── 執行Optuna優化
   ├── 在訓練集上找到最佳參數
   └── 在測試集上驗證

2. 自動驗證與應用
   ├── 如果測試集ROI > 閾值（如15%）
   │   ├── 自動更新config_usdttwd.yaml
   │   ├── 備份舊配置
   │   └── 發送Telegram通知
   └── 如果測試集ROI < 閾值
       └── 記錄結果，不更新配置

3. 實盤監控
   ├── 每日計算實際ROI
   ├── 與回測ROI對比
   └── 如果偏差過大，觸發重新優化
```

**實現檔案**：`auto_optimize.py`

```python
# 偽代碼
async def auto_optimize_workflow():
    # 1. 載入最新市場數據
    price_df = load_latest_market_data()
    
    # 2. 執行Optuna優化
    study = run_optuna_optimization(price_df)
    best_params = study.best_params
    
    # 3. 驗證最佳參數
    validation_roi = validate_params(best_params, test_set)
    
    # 4. 判斷是否應用
    if validation_roi > 0.15:  # 15% ROI閾值
        # 更新配置
        update_config_file(best_params)
        # 發送通知
        await alerter.send_strategy_event(
            f"✅ 參數優化完成！\n"
            f"測試集ROI: {validation_roi:.2%}\n"
            f"新參數已自動應用。"
        )
        # 重啟策略（可選）
        # restart_strategy()
    else:
        await alerter.send_strategy_event(
            f"⚠️ 參數優化完成，但測試集ROI ({validation_roi:.2%}) 未達閾值。\n"
            f"保持當前配置。"
        )
```

#### 方案B：整合回測與實盤 ⭐⭐⭐⭐

**問題**：回測和實盤使用不同代碼路徑

**建議**：
1. **統一策略邏輯**：
   ```python
   # 建立 strategy_core.py
   class GridStrategy:
       def __init__(self, config, mode='live'):  # 'live' or 'backtest'
           self.mode = mode
           self.config = config
       
       async def execute_order(self, order):
           if self.mode == 'live':
               return await max_api.place_v2_order(...)
           else:
               return self.simulate_order(order)
   ```

2. **實盤回測對比**：
   ```python
   # 每日對比實盤與回測結果
   def compare_live_vs_backtest():
       live_pnl = get_live_daily_pnl()
       backtest_pnl = run_backtest_for_today()
       
       if abs(live_pnl - backtest_pnl) / backtest_pnl > 0.2:
           # 偏差超過20%，觸發警報
           alert("實盤與回測偏差過大！")
   ```

#### 方案C：流程自動化腳本 ⭐⭐⭐⭐⭐

**建立**：`workflow_manager.py`

```python
"""
自動化工作流程管理器
"""
import schedule
import asyncio

class WorkflowManager:
    def __init__(self):
        self.setup_schedule()
    
    def setup_schedule(self):
        # 每週日凌晨2點執行參數優化
        schedule.every().sunday.at("02:00").do(self.weekly_optimization)
        
        # 每日凌晨3點執行回測驗證
        schedule.every().day.at("03:00").do(self.daily_validation)
        
        # 每小時檢查實盤績效
        schedule.every().hour.do(self.check_live_performance)
    
    async def weekly_optimization(self):
        """每週參數優化"""
        # 執行Optuna優化
        # 驗證結果
        # 自動應用（如果通過驗證）
        pass
    
    async def daily_validation(self):
        """每日回測驗證"""
        # 使用最新數據回測當前參數
        # 對比實盤結果
        pass
    
    async def check_live_performance(self):
        """檢查實盤績效"""
        # 計算當前ROI
        # 檢查是否達到目標
        # 觸發警報（如果需要）
        pass

# 運行
manager = WorkflowManager()
while True:
    schedule.run_pending()
    await asyncio.sleep(60)
```

### 流程整合建議

**推薦整合方案**：

```
┌─────────────────────────────────────────┐
│  1. 數據收集（每日自動）                │
│     - 下載最新K線數據                   │
│     - 更新回測數據集                    │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  2. 參數優化（每週自動）                │
│     - Optuna優化（訓練集）              │
│     - 驗證（測試集）                    │
│     - 如果ROI > 15%：自動應用           │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  3. 實盤運行（持續）                    │
│     - 使用最新參數                      │
│     - 記錄所有交易                      │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  4. 績效監控（每日自動）                │
│     - 計算實際ROI                       │
│     - 對比回測ROI                       │
│     - 如果偏差大：觸發重新優化          │
└─────────────────────────────────────────┘
```

### 具體實現步驟

1. **建立自動化腳本**：
   - `auto_optimize.py` - Optuna優化流程
   - `workflow_manager.py` - 工作流程管理
   - `data_collector.py` - 數據收集

2. **整合到現有系統**：
   - 在 `strategy_usdttwd_grid.py` 中加入參數熱更新
   - 建立參數版本管理系統

3. **監控與告警**：
   - 參數優化完成通知
   - 實盤與回測偏差告警
   - ROI目標達成通知

---

## 總結與優先級

### 優先級排序

**P0（立即實施）**：
1. ✅ 實現Optuna參數優化
2. ✅ 建立自動化優化流程
3. ✅ 實現混合模式（趨勢跟隨）

**P1（短期實施）**：
4. ✅ 優化網格間距（ATR動態調整）
5. ✅ 提升資金利用率
6. ✅ 手續費優化（maker訂單）

**P2（中期實施）**：
7. ✅ 統一回測與實盤代碼
8. ✅ 建立工作流程管理器
9. ✅ 實盤與回測對比監控

### 預期效果

實施所有優化後：
- **年化ROI目標**：15-25%（保守估計）
- **風險控制**：最大回撤 < 10%
- **自動化程度**：90%以上流程自動化

### 注意事項

1. **過度優化風險**：避免在單一數據集上過度擬合
2. **實盤驗證**：新參數應先小資金測試
3. **風險管理**：優化過程中保持風險控制機制
4. **監控機制**：建立完善的監控和告警系統

---

**最後更新**：2025-01-XX
**版本**：1.0

